diff --git a/node_modules/@remix-run/server-runtime/dist/data.js b/node_modules/@remix-run/server-runtime/dist/data.js
index 4ac203f..e6a7d23 100644
--- a/node_modules/@remix-run/server-runtime/dist/data.js
+++ b/node_modules/@remix-run/server-runtime/dist/data.js
@@ -66,6 +66,7 @@ async function callRouteLoader({
   request
 }) {
   let loader = match.route.module.loader;
+  console.log(request.url, 'calling loader', loader)
 
   if (!loader) {
     throw new Error(`You made a ${request.method} request to ${request.url} but did not provide ` + `a default component or \`loader\` for route "${match.route.id}", ` + `so there is no way to handle the request.`);
@@ -79,7 +80,9 @@ async function callRouteLoader({
       context: loadContext,
       params: match.params
     });
+    console.log(request.url, 'loader called', result)
   } catch (error) {
+    console.log(request.url, 'loader call error', error)
     if (!responses.isResponse(error)) {
       throw error;
     }
diff --git a/node_modules/@remix-run/server-runtime/dist/server.js b/node_modules/@remix-run/server-runtime/dist/server.js
index 45c51be..a9995b8 100644
--- a/node_modules/@remix-run/server-runtime/dist/server.js
+++ b/node_modules/@remix-run/server-runtime/dist/server.js
@@ -27,6 +27,7 @@ const createRequestHandler = (build, mode$1) => {
   let serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production;
   return async function requestHandler(request, loadContext) {
     let url = new URL(request.url);
+    console.log(request.url, 'requestHandler');
     let matches = routeMatching.matchServerRoutes(routes$1, url.pathname);
     let response;
 
@@ -46,6 +47,7 @@ const createRequestHandler = (build, mode$1) => {
         serverMode
       });
     } else {
+      console.log(request.url, 'handleDocumentRequest');
       response = await handleDocumentRequest({
         build,
         loadContext,
@@ -54,6 +56,7 @@ const createRequestHandler = (build, mode$1) => {
         routes: routes$1,
         serverMode
       });
+      console.log(request.url, 'document request response created', response);
     }
 
     if (request.method === "HEAD") {
@@ -165,6 +168,7 @@ async function handleDocumentRequest({
   routes,
   serverMode
 }) {
+  console.log('doc01', request.url)
   let url = new URL(request.url);
   let appState = {
     trackBoundaries: true,
@@ -177,6 +181,7 @@ async function handleDocumentRequest({
   };
 
   if (!isValidRequestMethod(request)) {
+    console.log('doc02', request.url)
     matches = null;
     appState.trackCatchBoundaries = false;
     appState.catch = {
@@ -185,6 +190,7 @@ async function handleDocumentRequest({
       statusText: "Method Not Allowed"
     };
   } else if (!matches) {
+    console.log('doc03', request.url)
     appState.trackCatchBoundaries = false;
     appState.catch = {
       data: null,
@@ -198,10 +204,13 @@ async function handleDocumentRequest({
   let actionMatch;
   let actionResponse;
 
+  console.log('doc04', request.url)
   if (matches && isActionRequest(request)) {
+    console.log('doc05', request.url)
     actionMatch = getRequestMatch(url, matches);
 
     try {
+      console.log('doc06', request.url)
       actionResponse = await data.callRouteAction({
         loadContext,
         match: actionMatch,
@@ -218,17 +227,20 @@ async function handleDocumentRequest({
       };
 
       if (responses.isCatchResponse(actionResponse)) {
+        console.log('doc07', request.url)
         appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
         appState.trackCatchBoundaries = false;
         appState.catch = { ...actionStatus,
           data: await data.extractData(actionResponse)
         };
       } else {
+        console.log('doc08', request.url)
         actionData = {
           [actionMatch.route.id]: await data.extractData(actionResponse)
         };
       }
     } catch (error) {
+      console.log('doc09', request.url)
       appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
       appState.trackBoundaries = false;
       appState.error = await errors.serializeError(error);
@@ -246,11 +258,14 @@ async function handleDocumentRequest({
   // is it supposed to deal with thrown responses and/or errors in the loader?
 
   if (appState.catch) {
+    console.log('doc10', request.url)
     matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "CatchBoundary").slice(0, -1);
   } else if (appState.error) {
+    console.log('doc11', request.url)
     matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "ErrorBoundary").slice(0, -1);
   }
 
+  console.log('doc12', request.url, matchesToLoad)
   let loaderRequest = new Request(request.url, {
     body: null,
     headers: request.headers,
@@ -258,15 +273,21 @@ async function handleDocumentRequest({
     redirect: request.redirect,
     signal: request.signal
   });
-  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map(match => match.route.module.loader ? data.callRouteLoader({
-    loadContext,
-    match,
-    request: loaderRequest
-  }) : Promise.resolve(undefined))); // Store the state of the action. We will use this to determine later
+  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map(async match => {
+    console.log('Calling loader for match', match.route.id)
+    const response = await (match.route.module.loader ? data.callRouteLoader({
+      loadContext,
+      match,
+      request: loaderRequest
+    }) : Promise.resolve(undefined))
+    console.log('Called loader for match', match.route.id, response)
+    return response
+  })); // Store the state of the action. We will use this to determine later
   // what catch or error boundary should be rendered under cases where
   // actions don't throw but loaders do, actions throw and parent loaders
   // also throw, etc.
 
+  console.log('doc13', request.url)
   let actionCatch = appState.catch;
   let actionError = appState.error;
   let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
@@ -279,6 +300,7 @@ async function handleDocumentRequest({
   let loaderStatusCodes = [];
   let routeData = {};
 
+  console.log('doc14', request.url)
   for (let index = 0; index < matchesToLoad.length; index++) {
     let match = matchesToLoad[index];
     let result = routeLoaderResults[index];
@@ -343,12 +365,15 @@ async function handleDocumentRequest({
   // initially triggered a boundary as that match would not exist in the
   // matches to load.
 
+  console.log('doc15', request.url)
 
   if (!appState.catch) {
+    console.log('doc16', request.url)
     appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
   }
 
   if (!appState.error) {
+    console.log('doc17', request.url)
     appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
   } // If there was an action error or catch, we will reset the state to the
   // initial values, otherwise we will use whatever came out of the loaders.
@@ -358,7 +383,9 @@ async function handleDocumentRequest({
   appState.error = actionError || appState.error;
   let renderableMatches = getRenderableMatches(matches, appState);
 
+  console.log('doc18', request.url)
   if (!renderableMatches) {
+    console.log('doc19', request.url)
     renderableMatches = [];
     let root = routes[0];
 
@@ -374,6 +401,7 @@ async function handleDocumentRequest({
   // non-200 status code determines the status code for the whole response.
 
 
+  console.log('doc20', request.url)
   let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find(status => status !== 200);
   let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
   let responseHeaders = headers.getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
@@ -384,6 +412,7 @@ async function handleDocumentRequest({
     matches: entryMatches,
     routeData
   };
+  console.log('doc21', request.url)
   let entryContext = { ...serverHandoff$1,
     manifest: build.assets,
     routeModules,
@@ -392,8 +421,10 @@ async function handleDocumentRequest({
   let handleDocumentRequest = build.entry.module.default;
 
   try {
+    console.log('doc22', request.url)
     return await handleDocumentRequest(request, responseStatusCode, responseHeaders, entryContext);
   } catch (error) {
+    console.log('doc23', request.url)
     responseStatusCode = 500; // Go again, this time with the componentDidCatch emulation. As it rendered
     // last time we mutated `componentDidCatch.routeId` for the last rendered
     // route, now we know where to render the error boundary (feels a little
@@ -406,8 +437,10 @@ async function handleDocumentRequest({
     entryContext.serverHandoffString = serverHandoff.createServerHandoffString(serverHandoff$1);
 
     try {
+      console.log('doc24', request.url)
       return await handleDocumentRequest(request, responseStatusCode, responseHeaders, entryContext);
     } catch (error) {
+      console.log('doc25', request.url)
       if (serverMode !== mode.ServerMode.Test) {
         console.error(error);
       }
